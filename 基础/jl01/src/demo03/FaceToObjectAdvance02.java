package demo03;

/**面向对象进阶2
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 多态：
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
*  定义：同类的对象，表现出不同的形态
*  表现形式：父类类型 对象名称 = 子类对象;
*  前提：1、有继承关系
*       2、有父类引用指向子类对象
*       3、有方法重写
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 调用成员特点：
 *      1、变量调用：编译看左边（看父类中是否有该变量），运行看左边（获取左边父类中成员变量的值）
 *      2、方法调用：编译看左边（看父类中是否有该方法），运行看右边（调用右边子类中成员方法）
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 优势：
 *      1、多态形式下，右边对象可以实现解耦合，便于扩展和维护
 *      2、定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 弊端：不能调用子类的特有功能
 * 解决方法：变回子类类型 => 强转（父类定义强转为子类）
 * 判断类型转换：变量名 instanceof 类名
 *      新特性：变量名 instanceof 类名 变量名  =>  判断前者是不是对应类，如果是，则强转变量名为后者，如果不是，则返回false
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 包：
 *      即文件夹，用于管理各种不同功能的Java类，方便后期代码维护
 *      包名规则：公司域名反写 + 包的作用，需要全部英文小写，见名知义
 *      全类名/全限定名：包名.类名
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 *      import：导包
 *      不需要导包：
 *          1、使用同一个包中的类
 *          2、使用java.lang包中的类
 *      如果同时使用两个包中的同名类，需要使用全类名
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * final关键字：不可被改变
 *      1、修饰方法：表明该方法是最终方法，不能被重写（表示某种规则时常用）
 *      2、修饰变量：叫做常量，只能被赋值一次（一般用作系统的配置信息，方便维护，可读性高） => 命名：全部大写，下划线隔开
 *      3、修饰类：最终类，不能被继承
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 权限修饰符：private（同一个类中） < 空（同一个包中） < protected（不同包的子类中） < public（任意）
 *            实际多用private和public，成员变量私有，成员方法公开
 *            特例：如果方法中的代码是抽取其他方法中的共性代码，则该方法一般也私有
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 代码块（一对单独的大括号）：
 *      1、局部代码块：方法内部的代码块 => 提前结束变量的生命周期                                   （很少用）
 *      2、构造代码块：写在成员位置的代码块，可以把多个构造方法中重复的代码抽取出来，优先于构造方法执行（很少用）
 *      3、静态代码块：static{}，随着类的加载而加载，自动触发，只执行一次，可以应用于数据初始化      （很常用）
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 抽象方法：将共性的行为（方法）抽取到父类之后，由于每个子类执行内容不同，因此父类不能确定具体的方法体，则定义为抽象方法
 * 抽象类：如果一个类中存在抽象方法，那么该类必须声明为抽象类
 * 定义格式：public abstract 返回值 方法名(参数列表);
 *          public abstract class 类名 {}
 * 注意：1、抽象类不能实例化
 *      2、抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类
 *      3、可以有构造方法（用于给子类对象赋值）
 *      4、抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类
 * 意义：规范代码，便于使用
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 接口：就是一种规则，是对行为的抽象
 * 接口定义：关键字interface定义 => public interface 接口名 {}
 * 接口使用：不能实例化，与类之间是实现关系，通过关键字implements表示 => public class 类名 implements 接口名{}
 * 接口的子类（实现类）：要么重写接口中的所有抽象方法，要么是抽象类
 * 注意：1、接口和类的实现关系可以单实现，也可以多实现
 *      2、实现类可以在继承一个类的同时实现多个接口
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 接口中成员的特点：
 *      1、成员变量：只能是常量，默认修饰符 => public static final
 *      2、构造方法：无
 *      3、成员方法：只能是抽象方法，默认修饰符 => public abstract
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 接口和类之间的关系：
 *      1、类和类关系：继承关系，只能单继承，但是可以多层继承
 *      2、类和接口关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
 *      3、接口和接口关系：继承关系，可以单继承，也可以多继承（如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法）
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 * 接口补充扩展：
 *      1、JDK8接口新增方法：可以定义含有方法体的方法（默认、静态）
 *                          默认需要使用default修饰（重写时去掉default）
 *                          静态：static修饰，只能通过接口名调用，不可重写
 *                          如果实现的多个接口中存在同名默认方法，必须重写
 *        JDK9：可以定义私有方法，存在普通private（为默认方法服务）和static private（为静态方法服务）
 *      2、接口应用：
 *          （1）接口代表规则，是行为的抽象，用类实现接口即可让类拥有对应行为
 *          （2）当一个方法的参数是接口时，可以传递接口所有实现类的对象，称之为接口多态
 *      3、适配器设计模式：解决接口与接口的实现类之间的矛盾问题
 *        适配器（起名：XXXAdapter）：一个没有抽象方法的抽象类，将接口中的抽象方法空实现，相当于一个中转接口，使得最终实现类不需
 *                                  要将接口中的所有方法都重写一遍
 * ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 */

public class FaceToObjectAdvance02 {
    public static void main(String[] args) {
        //测试多态
        Students s1 = new Students("张三", 18, "s001");
        Teachers t1 = new Teachers("Miss. Li", 29, "t001");
        Administrators a1 = new Administrators("Dirt", 40, "a001");
        testRegister(s1);
        testRegister(t1);
        testRegister(a1);

        //强转
        Person p1 = new Students("李四", 18, "s002");
        testRegister(p1);
        Students s2 = (Students) p1;
        s2.cheat();

        //测试抽象类
        Frogs_abstract f1 = new Frogs_abstract("小F", 5);
        Dogs_abstract d1 = new Dogs_abstract("小D", 2);
        Goats_abstract g1 = new Goats_abstract("小G",6);
        Rabbits_abstract r1 = new Rabbits_abstract("小R",5);
        f1.drink();
        d1.drink();
        g1.drink();
        r1.drink();
        f1.eat();
        d1.eat();
        g1.eat();
        r1.eat();
        f1.swim();
        d1.swim();
    }

    //测试
    public static void testRegister(Person person) {
        person.show();
    }

}

